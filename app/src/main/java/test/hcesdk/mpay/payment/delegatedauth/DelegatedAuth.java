package test.hcesdk.mpay.payment.delegatedauth;import android.Manifest;import android.annotation.SuppressLint;import android.app.KeyguardManager;import android.content.Context;import android.content.DialogInterface;import android.content.pm.PackageManager;import android.hardware.biometrics.BiometricManager;import android.hardware.biometrics.BiometricPrompt;import android.hardware.fingerprint.FingerprintManager;import android.os.Build;import android.util.Log;import androidx.annotation.NonNull;import androidx.annotation.RequiresApi;import androidx.core.app.ActivityCompat;import androidx.core.hardware.fingerprint.FingerprintManagerCompat;import com.gemalto.mfs.mwsdk.cdcvm.BiometricsSupport;import com.gemalto.mfs.mwsdk.sdkconfig.AndroidContextResolver;import test.hcesdk.mpay.R;public class DelegatedAuth {    private static String TAG = DelegatedAuth.class.getName();    private Context context;    private DeviceCVMVerifierInput input;    private static final String ONEPLUS = "OnePlus";    private static final String XIAOMI = "Xiaomi";    public DelegatedAuth(Context context) {        this.context = context;    }    public void authenticate(DelegatedAuthCallback authenticationCallback, String description) throws Exception {        input = new DeviceCVMVerifierInput(context.getString(R.string.verify_using_fingerprint), context.getString(R.string.verify_by_keyguard_msg),                description, "Cancel");        if (Build.VERSION.SDK_INT > Build.VERSION_CODES.Q) {            authenticateRandAbove(authenticationCallback);        } else if (Build.VERSION.SDK_INT == Build.VERSION_CODES.Q) {            authenticateQ(authenticationCallback);        } else {            authenticatePreQ(authenticationCallback);        }    }    /**     * Authenticates using {@link BiometricPrompt}.     */    @SuppressLint("MissingPermission")    @RequiresApi(Build.VERSION_CODES.Q)    private void authenticateQ(@NonNull final DelegatedAuthCallback authenticationCallback) throws Exception {        Log.i(TAG, "authenticateQ> started");        Log.d(TAG, "Device type is: " + Build.MANUFACTURER);        final KeyguardManager keyguardManager = (KeyguardManager)                context.getSystemService(Context.KEYGUARD_SERVICE);        // Should not happen.        if (keyguardManager == null) {            throw new Exception("Unable to get KeyguardManager service!");        }        final boolean fallbackEnabled;        BiometricPrompt.Builder builder = new BiometricPrompt.Builder(context)                .setTitle(input.getTitle())                .setSubtitle(input.getSubtitle())                .setDescription(input.getDescription());        // If device has PIN / Pattern / Password set, enable the fallback mechanism.        // Else, just provide a cancel button.        if (keyguardManager.isDeviceSecure() && !isDeviceLocked()) {            /*Fallback Keyguard option disabled for Xiaomi devices version 10 and Above             */            //https://developers.google.com/zero-touch/resources/manufacturer-names : Manufacture name arrived from here            // https://developers.google.com/zero-touch/resources/manufacturer-names : Manufacture name arrived from here            // We only disable Device Keyguard fallback for Xiaomi Android 10, e.g. Xiaomi Mi 9T (Android 10).            Log.i(TAG, "Build.VERSION.SDK_INT: " + Build.VERSION.SDK_INT);            if (Build.MANUFACTURER.equalsIgnoreCase(XIAOMI) && Build.VERSION.SDK_INT == Build.VERSION_CODES.Q) {                Log.i(TAG, "Xiaomi device is  detected  Android version 10 and above");                Log.i(TAG, "authenticate Q> fallback authentication disabled!");                // For SDK track purpose                fallbackEnabled = false;                BiometricsSupport biometricsSupport = checkBiometricsSupport(context);                Log.i(TAG, "biometricsSupport String: " + biometricsSupport.name());                Log.i(TAG, "biometricsSupport ordinal: " + biometricsSupport.ordinal());                if (biometricsSupport != BiometricsSupport.SUPPORTED) {                    Log.i(TAG, "Xiaomi keyguard Enabled if no biometrics enrolled");                    builder = builder.setDeviceCredentialAllowed(true);                } else {                    Log.i(TAG, "Xiaomi keyguard not Enabled");                    builder = builder.setDeviceCredentialAllowed(false);                    builder = builder.setNegativeButton(                            input.getNegativeButtonText(),                            context.getMainExecutor(),                            new DialogInterface.OnClickListener() {                                @Override                                public void onClick(DialogInterface dialogInterface, int i) {                                    Log.i(TAG, "authenticateQ> Cancel");                                    input.getDeviceCVMCancellationSignalQ().cancel();                                    if (null != authenticationCallback) {                                        // When Cancel is clicked return this error to MPA                                        authenticationCallback.onAuthenticationError(BiometricPrompt.BIOMETRIC_ERROR_USER_CANCELED, "User has clicked Cancel Button");                                    }                                }                            });                }            } else {                Log.d(TAG, "authenticateQ> fallback authentication enabled!");                fallbackEnabled = true;                builder = builder.setDeviceCredentialAllowed(true);            }        } else {            Log.d(TAG, "authenticateQ> fallback authentication disabled! for all except onePlus Device");            // Allow payment on top of lock screen for OnePlus device.            // And we do now need cancel button on top of lock screen            fallbackEnabled = Build.MANUFACTURER.equalsIgnoreCase(ONEPLUS);            if (!Build.MANUFACTURER.equalsIgnoreCase(ONEPLUS)) {                builder = builder.setNegativeButton(                        input.getNegativeButtonText(),                        context.getMainExecutor(),                        new DialogInterface.OnClickListener() {                            @Override                            public void onClick(DialogInterface dialogInterface, int i) {                                Log.i(TAG, "authenticateQ> Cancel");                                input.getDeviceCVMCancellationSignalQ().cancel();                                if (null != authenticationCallback) {                                    authenticationCallback.onAuthenticationError(BiometricPrompt.BIOMETRIC_ERROR_USER_CANCELED, "User has clicked Cancel Button");                                }                            }                        });            } else {                builder = builder.setDeviceCredentialAllowed(true);            }        }        Log.d(TAG, "authenticateQ> Launching BiometricPrompt...");        builder.build().authenticate(                input.getDeviceCVMCancellationSignalQ(),                context.getMainExecutor(),                new BiometricPrompt.AuthenticationCallback() {                    @Override                    public void onAuthenticationError(int errorCode, CharSequence errString) {                        Log.d(TAG, "BiometricPrompt.onAuthenticationError> errorCode = " + errorCode);                        Log.d(TAG, "BiometricPrompt.onAuthenticationError> errString = " + errString);                        Log.d(TAG, "BiometricPrompt.onAuthenticationError> fallbackEnabled = " + fallbackEnabled);                        Log.d(TAG, "BiometricPrompt.onAuthenticationError> propagating error...");                        authenticationCallback.onAuthenticationError(errorCode, errString);                    }                    @Override                    public void onAuthenticationHelp(int helpCode, CharSequence helpString) {                        Log.d(TAG, "BiometricPrompt.onAuthenticationHelp> helpCode = " + helpCode);                        Log.d(TAG, "BiometricPrompt.onAuthenticationHelp> helpString = " + helpString);                        authenticationCallback.onAuthenticationHelp(helpCode, helpString);                    }                    @Override                    public void onAuthenticationSucceeded(BiometricPrompt.AuthenticationResult result) {                        Log.d(TAG, "BiometricPrompt.onAuthenticationSucceeded> result = " + result);                        authenticationCallback.onAuthenticationSucceeded();                    }                    @Override                    public void onAuthenticationFailed() {                        Log.d(TAG, "BiometricPrompt.onAuthenticationFailed>");                        authenticationCallback.onAuthenticationFailed();                    }                }        );    }    /**     * Authenticates using {@link BiometricPrompt}.     */    @SuppressLint("MissingPermission")    @RequiresApi(Build.VERSION_CODES.R)    private void authenticateRandAbove(            @NonNull final DelegatedAuthCallback authenticationCallback) throws Exception {        Log.i(TAG, "authenticateRandAbove> started");        Log.d(TAG, "Device type is: " + Build.MANUFACTURER);        final KeyguardManager keyguardManager = (KeyguardManager)                context.getSystemService(Context.KEYGUARD_SERVICE);        // Should not happen.        if (keyguardManager == null) {            throw new Exception("Unable to get KeyguardManager service!");        }        //fallback enabled by default        final boolean fallbackEnabled = true;        BiometricPrompt.Builder builder = new BiometricPrompt.Builder(context)                .setTitle(input.getTitle())                .setSubtitle(input.getSubtitle())                .setDescription(input.getDescription());        // If device has PIN / Pattern / Password set, enable the fallback mechanism.        // Else, just provide a cancel button.        builder = builder.setAllowedAuthenticators(                BiometricManager.Authenticators.BIOMETRIC_STRONG |                        BiometricManager.Authenticators.DEVICE_CREDENTIAL);        Log.d(TAG, "authenticateRandAbove> Launching BiometricPrompt...");        builder.build().authenticate(                input.getDeviceCVMCancellationSignalQ(),                context.getMainExecutor(),                new BiometricPrompt.AuthenticationCallback() {                    @Override                    public void onAuthenticationError(int errorCode, CharSequence errString) {                        Log.d(TAG, "BiometricPrompt.onAuthenticationError> errorCode = " + errorCode);                        Log.d(TAG, "BiometricPrompt.onAuthenticationError> errString = " + errString);                        Log.d(TAG, "BiometricPrompt.onAuthenticationError> fallbackEnabled = " + fallbackEnabled);                        Log.d(TAG, "BiometricPrompt.onAuthenticationError> propagating error...");                        authenticationCallback.onAuthenticationError(errorCode, errString);                    }                    @Override                    public void onAuthenticationHelp(int helpCode, CharSequence helpString) {                        Log.d(TAG, "BiometricPrompt.onAuthenticationHelp> helpCode = " + helpCode);                        Log.d(TAG, "BiometricPrompt.onAuthenticationHelp> helpString = " + helpString);                        authenticationCallback.onAuthenticationHelp(helpCode, helpString);                    }                    @Override                    public void onAuthenticationSucceeded(BiometricPrompt.AuthenticationResult result) {                        Log.d(TAG, "BiometricPrompt.onAuthenticationSucceeded> result = " + result);                        authenticationCallback.onAuthenticationSucceeded();                    }                    @Override                    public void onAuthenticationFailed() {                        Log.d(TAG, "BiometricPrompt.onAuthenticationFailed>");                        authenticationCallback.onAuthenticationFailed();                    }                }        );    }    @SuppressWarnings({"MissingPermission"})    /** Authenticates using {@link FingerprintManagerCompat}. */    private void authenticatePreQ(            @NonNull final DelegatedAuthCallback authenticationCallback) {        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.Q) {            Log.i(TAG, "authenticatePreQ> Starting FingerprintManagerCompat...");            FingerprintManagerCompat fingerprintManager = FingerprintManagerCompat.from(context);            fingerprintManager.authenticate(                    null,                    0,                    input.getDeviceCVMCancellationSignalO(),                    new FingerprintManagerCompat.AuthenticationCallback() {                        @Override                        public void onAuthenticationError(int errorCode, CharSequence errString) {                            Log.d(TAG, "FingerprintManagerCompat.onAuthenticationError> errorCode = " + errorCode);                            Log.d(TAG, "FingerprintManagerCompat.onAuthenticationError> errString = " + errString);                            // Pass the BiometricPrompt code equivalent to the MPA if there is.                            // If there's no equivalent, pass the original code.                            authenticationCallback.onAuthenticationError(errorCode, errString);                        }                        @Override                        public void onAuthenticationHelp(int helpCode, CharSequence helpString) {                            Log.d(TAG, "FingerprintManagerCompat.onAuthenticationHelp> helpCode = " + helpCode);                            Log.d(TAG, "FingerprintManagerCompat.onAuthenticationHelp> helpString = " + helpString);                            authenticationCallback.onAuthenticationHelp(helpCode, helpString);                        }                        @Override                        public void onAuthenticationSucceeded(FingerprintManagerCompat.AuthenticationResult result) {                            Log.d(TAG, "FingerprintManagerCompat.onAuthenticationSucceeded> result = " + result);                            authenticationCallback.onAuthenticationSucceeded();                        }                        @Override                        public void onAuthenticationFailed() {                            Log.d(TAG, "FingerprintManagerCompat.onAuthenticationFailed>");                            authenticationCallback.onAuthenticationFailed();                        }                    },                    null            );        }    }    /**     * Checks if biometric authentication is supported or not.     *     * @param context {@link Context} used for obtaining device resources.     * @return {@link BiometricsSupport} value indicating whether or not biometric authentication is     * supported.     */    @SuppressWarnings({"MissingPermission"})    static BiometricsSupport checkBiometricsSupport(@NonNull Context context) throws Exception {        Log.d(TAG, "checkBiometricsSupport> SDK_INT = " + Build.VERSION.SDK_INT);        final BiometricsSupport result;        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {            result = checkBiometricsSupportQandAbove(context, false);        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {            result = checkBiometricsSupportPreQ(context);        } else {            result = BiometricsSupport.ANDROID_VERSION_NOT_SUPPORTED;        }        Log.d(TAG, "checkBiometricsSupport> result = " + result);        return result;    }    /**     * For all Android versions before Q, that is Android M - Android P, we use KeyguardManager     *     * @return     */    @SuppressLint("MissingPermission")    static BiometricsSupport checkBiometricsSupportPreQ(Context context) {        final KeyguardManager kgManager = (KeyguardManager) context.getSystemService(Context.KEYGUARD_SERVICE);        final BiometricsSupport result;        // Should not happen.        if (kgManager == null || !kgManager.isKeyguardSecure()) {            result = BiometricsSupport.SECURE_LOCK_NOT_PRESENTED;        } else {            if (ActivityCompat.checkSelfPermission(context, Manifest.permission.USE_FINGERPRINT) == PackageManager.PERMISSION_GRANTED) {                final FingerprintManager fpManager = (FingerprintManager) context.getSystemService(Context.FINGERPRINT_SERVICE);                // Should not happen.                if (fpManager == null) {                    return BiometricsSupport.NO_FINGERPRINT_SENSOR;                }                if (!fpManager.isHardwareDetected()) {                    result = BiometricsSupport.NO_FINGERPRINT_SENSOR;                } else if (!fpManager.hasEnrolledFingerprints()) {                    result = BiometricsSupport.NO_FINGERPRINT_ENROLLED;                } else {                    result = BiometricsSupport.SUPPORTED;                }            } else {                result = BiometricsSupport.PERMISSION_NOT_GRANTED;            }        }        return result;    }    /**     * From Android Q, we start to use BiometricManager.     *     * @param context     * @return     */    @SuppressLint("MissingPermission")    @RequiresApi(api = Build.VERSION_CODES.Q)    static BiometricsSupport checkBiometricsSupportQandAbove(@NonNull Context context, boolean bDuringPayment) throws Exception {        final BiometricManager biometricManager = context.getSystemService(BiometricManager.class);        final KeyguardManager kgManager = (KeyguardManager) context.getSystemService(Context.KEYGUARD_SERVICE);        // Should not happen.        if (kgManager == null || !kgManager.isKeyguardSecure()) {            return BiometricsSupport.SECURE_LOCK_NOT_PRESENTED;        }        // Should not happen.        if (biometricManager == null) {            return BiometricsSupport.NO_FINGERPRINT_SENSOR;        }        // Should not happen.        if (kgManager == null) {            throw new Exception("Unable to get KeyguardManager service!");        }        final BiometricsSupport result;        final int canAuthenticate;        /*         API canAuthenticate is different between Android Q and Android R+,         we need to distinguish them.         */        if (Build.VERSION.SDK_INT == Build.VERSION_CODES.Q) {            canAuthenticate = biometricManager.canAuthenticate();        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {            if (bDuringPayment) {             /*                During Payment, we check if it is possible to use DEVICE_CREDENTIAL or BIOMETRIC.                The reason is if SDK < 6.4.0 was initially run on Android 11 devices with only Face+Keyguard Enrolled,                CDCVM type will be stored as Biometric. With 6.4.0, on Android 11, Face is considered                as Weak, so canAuthenticate(BIOMETRIC_STRONG) will return as NOT_SUPPORTED, hence                this will trigger SDK wipe. To avoid it, DEVICE_CREDENTIAL is used along with                BIOMETRIC_STRONG             */                canAuthenticate = biometricManager.canAuthenticate(                        BiometricManager.Authenticators.BIOMETRIC_STRONG | BiometricManager.Authenticators.DEVICE_CREDENTIAL);            } else {                canAuthenticate = biometricManager.canAuthenticate(BiometricManager.Authenticators.BIOMETRIC_STRONG);            }        } else {            canAuthenticate = BiometricManager.BIOMETRIC_ERROR_HW_UNAVAILABLE;        }        Log.d(TAG, "checkBiometricsSupport> canAuthenticate = " + canAuthenticate);        switch (canAuthenticate) {            case BiometricManager.BIOMETRIC_SUCCESS:                if (!kgManager.isKeyguardSecure()) {                    result = BiometricsSupport.SECURE_LOCK_NOT_PRESENTED;                } else {                    result = BiometricsSupport.SUPPORTED;                }                break;            case BiometricManager.BIOMETRIC_ERROR_SECURITY_UPDATE_REQUIRED:                result = BiometricsSupport.SECURITY_UPDATE_REQUIRED;                break;            case BiometricManager.BIOMETRIC_ERROR_NONE_ENROLLED:                result = BiometricsSupport.NO_FINGERPRINT_ENROLLED;                break;            // For now, treat HW unavailable, no HW and other errors as NO_FINGERPRINT_SENSOR.            // May be better to rename NO_FINGERPRINT_SENSOR to FINGERPRINT_SENSOR_UNAVAILABLE.            case BiometricManager.BIOMETRIC_ERROR_HW_UNAVAILABLE:            case BiometricManager.BIOMETRIC_ERROR_NO_HARDWARE:            default:                result = BiometricsSupport.NO_FINGERPRINT_SENSOR;        }        return result;    }    public void cancel() {        Log.d(TAG, "DeviceCVMCancellationSignal cancel");        Log.i(TAG, "Cancel biometric prompt invoked from user");        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {            if (!input.getDeviceCVMCancellationSignalQ().isCanceled()) {                input.getDeviceCVMCancellationSignalQ().cancel();            } else {                Log.i(TAG, "qCancellationSignal.isCanceled(): true");            }        } else {            if (!input.getDeviceCVMCancellationSignalO().isCanceled()) {                input.getDeviceCVMCancellationSignalO().cancel();            } else {                Log.i(TAG, "oCancellationSignal.isCanceled(): true");            }        }    }    public static boolean isDeviceLocked() {        Log.i(TAG, "DeviceUtil: Checking is device locked or not");        KeyguardManager keyguardManager = (KeyguardManager) AndroidContextResolver.getApplicationContext().getSystemService(Context.KEYGUARD_SERVICE);        boolean isDeviceLocked = keyguardManager != null && keyguardManager.inKeyguardRestrictedInputMode();        Log.i(TAG, "DeviceUtil: is device locked ?" + isDeviceLocked);        return isDeviceLocked;    }}