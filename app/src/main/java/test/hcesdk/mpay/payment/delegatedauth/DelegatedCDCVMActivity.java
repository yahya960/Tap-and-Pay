package test.hcesdk.mpay.payment.delegatedauth;import android.annotation.TargetApi;import android.app.KeyguardManager;import android.content.Context;import android.content.Intent;import android.hardware.biometrics.BiometricPrompt;import android.os.Build;import android.os.Bundle;import android.os.Handler;import android.os.PowerManager;import android.util.Log;import android.view.View;import android.view.WindowManager;import android.widget.TextView;import androidx.annotation.Nullable;import androidx.appcompat.app.AppCompatActivity;import com.gemalto.mfs.mwsdk.cdcvm.BiometricsSupport;import com.gemalto.mfs.mwsdk.cdcvm.DeviceCVMEligibilityChecker;import com.gemalto.mfs.mwsdk.cdcvm.DeviceCVMEligibilityResult;import com.gemalto.mfs.mwsdk.cdcvm.DeviceKeyguardSupport;import com.gemalto.mfs.mwsdk.payment.CHVerificationMethod;import test.hcesdk.mpay.R;public class DelegatedCDCVMActivity extends AppCompatActivity {    private static final String TAG = DelegatedCDCVMActivity.class.getName();    public static final int REQUEST_CODE_KEYGUARD_AUTHENTICATE = 100;    private static final int MAX_ATTEMPT_COUNT = 5;    private static final int RESET_DELAY_TIME = 1500;    public static final String EXTRA_CVM = "EXTRA_CVM";    public static final String EXTRA_TITLE = "EXTRA_TITLE";    public static final String EXTRA_DESCRIPTION = "EXTRA_DESCRIPTION";    private CharSequence title;    private CharSequence description;    private CHVerificationMethod cvm;    private PowerManager.WakeLock mWakeLock;    private TextView fingerprintText;    private View btnKeyguardVer;    private View progressLayout;    private View mainLayout;    private TextView tvAmount;    private boolean tooManyAttempt;    @Override    protected void onCreate(@Nullable Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        Log.d(TAG, "Auth Screen Display STARTED");        unlockAndWake();        setContentView(R.layout.activity_cvm);        fingerprintText = findViewById(R.id.message);        btnKeyguardVer = findViewById(R.id.btn_keyguard_verification);        progressLayout = findViewById(R.id.progress_layout);        mainLayout = findViewById(R.id.mainLayout);        tvAmount = findViewById(R.id.tv_amount);        Bundle extras = getIntent().getExtras();        cvm = (CHVerificationMethod) extras.getSerializable(EXTRA_CVM);        title = extras.getString(EXTRA_TITLE);        description = extras.getString(EXTRA_DESCRIPTION);        if(description.toString().isEmpty()) {            description = title;            findViewById(R.id.tv_amount_title).setVisibility(View.INVISIBLE);        }        tvAmount.setText(description);        if (cvm == CHVerificationMethod.BIOMETRICS) {            //If on top of lock screen and in Android9 device,            // show keyguard button for user to authenticate            if (isRestrictModeEnabled() && Build.VERSION.SDK_INT == 28) {                btnKeyguardVer.setVisibility(View.VISIBLE);            }            try {                new DelegatedAuth(this)                        .authenticate(authenticationCallback, description.toString());            } catch (Exception exception) {                Log.e(TAG, exception.getMessage());            }        } else {            progressLayout.setVisibility(View.VISIBLE);            confirmCredential();        }        btnKeyguardVer.setOnClickListener(view -> {            confirmCredential();        });    }    @Override    protected void onDestroy() {        Log.i(TAG, "onDestroy>");        Log.d(TAG, "DelegatedCDCVMActivity onDestroy");        super.onDestroy();    }    @Override    protected void onStart() {        Log.i(TAG, "onStart>");        Log.d(TAG, "DelegatedCDCVMActivity onStart");        super.onStart();    }    @Override    protected void onStop() {        super.onStop();        releaseWakeLockAndClearFlag();    }    DelegatedAuthCallback authenticationCallback = new DelegatedAuthCallback() {        @Override        public void onAuthenticationError(int errorCode, CharSequence errString) {            Log.e(TAG, "===> onAuthenticationHelp " + errString.toString() + " " + errorCode);            if (errorCode == BiometricPrompt.BIOMETRIC_ERROR_USER_CANCELED) {                //User cancelled action                if (Build.VERSION.SDK_INT >= 29) {                    setResult(RESULT_CANCELED);                    finish();                } else {                    enableFallBackMechanism(errString.toString(), MAX_ATTEMPT_COUNT);                }            } else {                enableFallBackMechanism(errString.toString(), MAX_ATTEMPT_COUNT);            }        }        @Override        public void onAuthenticationHelp(int helpCode, CharSequence helpString) {            Log.e(TAG, "===> onAuthenticationHelp " + helpString.toString() + " " + helpCode);        }        @Override        public void onAuthenticationSucceeded() {            Log.e(TAG, "===> onAuthenticationSucceeded");            setResult(RESULT_OK);            overridePendingTransition(0, 0);            finish();        }        @Override        public void onAuthenticationFailed() {            Log.e(TAG, "===> onAuthenticationFailed");            resetTextMessage(getString(R.string.unable_to_recognise_fingerprint));        }    };    private void resetTextMessage(String message) {        Log.e(TAG, "resetTextMessage(): " + message);        fingerprintText.setText(message);        fingerprintText.setTextColor(getResources().getColor(R.color.text_color_5));        new Handler().postDelayed(() -> {            if (!tooManyAttempt) {                fingerprintText.setText(getString(R.string.tap_finger_print));                fingerprintText.setTextColor(getResources().getColor(R.color.text_color_1));            }        }, RESET_DELAY_TIME);    }    private void enableFallBackMechanism(String message, int attemptCount) {        if (attemptCount >= MAX_ATTEMPT_COUNT) {            tooManyAttempt = true;        }        resetTextMessage(message);        setKeyguardFallbackButtonVisible();    }    private void setKeyguardFallbackButtonVisible() {        if (btnKeyguardVer != null) {            if (Build.VERSION.SDK_INT >= 29) {                /*                 * For Android Q, fallback happens within biometric prompt itself. There is no need have fallback mechanism in the UI.                 * More importantly, it will not work in Android Q devices anyways. So , this button can be an issue for UX.                 */                btnKeyguardVer.setVisibility(View.GONE);            } else {                btnKeyguardVer.setVisibility(View.VISIBLE);            }        }    }    /**     * An API to launch the fallback mechanism. Fallback can either be PIN / Pattern / Password     * defined by the end-user in the Android settings.     * <br/>     * <b>NOTE:<b/>The SDK will verify if the device is secured with a PIN, pattern or password. If not,     * a {@link RuntimeException} will be raised.     */    @TargetApi(Build.VERSION_CODES.M)    private void confirmCredential() {        Log.i(TAG, "confirmCredential> starting keyguard...");        Log.d(TAG, "DelegatedCDCVMActivity confirmCredential");        DeviceCVMEligibilityResult result = DeviceCVMEligibilityChecker.checkDeviceEligibility(this);        if (result.getBiometricsSupport() == BiometricsSupport.SUPPORTED ||                result.getDeviceKeyguardSupport() == DeviceKeyguardSupport.SUPPORTED) {            KeyguardManager keyguardManager = (KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE);            if (!keyguardManager.isDeviceSecure()) {                setResult(RESULT_CANCELED); // DeviceKeyguard is not supported                finish();            }            Intent intent = keyguardManager.createConfirmDeviceCredentialIntent(title, description);            startActivityForResult(intent, REQUEST_CODE_KEYGUARD_AUTHENTICATE);        }    }    @Override    public void onActivityResult(int requestCode, int resultCode, Intent data) {        Log.d(TAG, "DelegatedCDCVMActivity onActivityResult");        Log.i(TAG, "onActivityResult> requestCode = " + requestCode);        Log.i(TAG, "onActivityResult> resultCode = " + resultCode);        super.onActivityResult(requestCode, resultCode, data);        privateOnActivityResult(requestCode, resultCode, data);    }    private void privateOnActivityResult(int requestCode, int resultCode, Intent data) {        if (requestCode == REQUEST_CODE_KEYGUARD_AUTHENTICATE) {            setResult(resultCode);            Log.e(TAG, "DeviceCVMDefaultKeyguardActivity.privateOnActivityResult() " + resultCode);            finish();        }    }    private void unlockAndWake() {        Log.d(TAG, ".unlockAndWake()");        //Return if mWakelock is non null as it's already initialized and acquired        if (mWakeLock != null && mWakeLock.isHeld())            return;        PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);        if (pm != null && !pm.isInteractive()) {            mWakeLock = pm.newWakeLock(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON                    | PowerManager.ACQUIRE_CAUSES_WAKEUP, getResources().getString(R.string.app_name) + "CA:wakelock");            if (mWakeLock != null)                mWakeLock.acquire();        }        getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED                | WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON                | WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON                | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);    }    private void releaseWakeLockAndClearFlag() {        Log.d(TAG, ".releaseWakeLockAndClearFlag()");        if (mWakeLock != null && mWakeLock.isHeld()) {            try {                mWakeLock.release();            } catch (Exception e) {                // Ignoring this exception, probably wakeLock was already released                Log.e(TAG, "Exception observed in releasing wakeLock");            } finally {                mWakeLock = null;            }        }        getWindow().clearFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED                | WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON                | WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON                | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);    }    /**     * @return true means on top of lock screen     */    private boolean isRestrictModeEnabled() {        KeyguardManager keyguardManager = (KeyguardManager) getApplication().getSystemService(Context.KEYGUARD_SERVICE);        //Check if in case the MPA is used for payment without unlocking device        return keyguardManager != null && keyguardManager.inKeyguardRestrictedInputMode();    }}